
Collection interview Question 3. What are subinterfaces of Collection interface in java? Is Map interface also a subinterface of Collection interface in java?

Answer. 

It’s important to note [Map] interface is a member of the Java Collections Framework, but it does not implement Collection interface in java.

Answer. This is very important collection framework interview question in java.

<table><colgroup><col width="23"><col width="85"><col width="249"><col width="267"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.ArrayList</span></p></td><td><p><span>java.util.LinkedList</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>Structure</span></p></td><td><p><span>java.util.ArrayList is index based structure in java.</span></p><p><a href="http://javamadesoeasy.com/2015/02/arraylist-custom-implementation.html"><span><img height="49px;" src="https://lh3.googleusercontent.com/wCfo_q1uxCzZZCgGpetqEQYMeVj9YMJokT9-WJ7QY4jxCF11u5-WVIjVheBCfKlPJtQ9Bp5zzxTJcPgYLMr0N3n6PvjXPzd-7O-FJr2KoW7qrUjERB-yXK2YxFkH6qrLAX6hvdg5" width="203px;"></span></a></p></td><td><p><span>A java.util.</span><span>LinkedList</span><span> is a data structure consisting of a group of </span><span>nodes </span><span>which together represent a sequence.</span></p><p><span>node is composed of a data and a reference (in other words, a </span><span>link</span><span>) to the next node in the sequence in java.</span></p><p><a href="http://www.javamadesoeasy.com/2015/01/doublylinkedlist-insert-and-delete-at.html"><span><img height="100px;" src="https://lh3.googleusercontent.com/ykSE04usYkDTj50vuGVTWKtVGJootTOKa07Eub-E6D5KkOCNAb399G4agtbSKOyeaPAUvAngY6JjDMs-SBNmblDOXLv62eHNVIwEuGD5-GNXTP45Ubtyp0BYg0seOxGSpXHatWJP" width="261px;"></span></a></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Resizable</span></p></td><td><p><span>ArrayList is Resizable-array in java.</span></p></td><td><p><span>New node is created for storing new element in LinkedList in java.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Initial capacity</span></p></td><td><p><span>java.util.ArrayList is created with initial capacity of 10 in java.</span></p></td><td><p><span>For storing every element node is created in LinkedList, so linkedList’s initial capacity is 0 in java.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Ensuring </span><span>Capacity</span><span>/ resizing.</span></p></td><td><p><span>ArrayList is created with initial capacity of 10.</span></p><p><span>ArrayList’s size is </span><span>increased by 50% </span><span>i.e. after resizing it’s size become 15 in java.</span></p></td><td><p><span>For storing every element node is created, so linkedList’s initial capacity is 0, it’s size grow with addition of each and every element in java.</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>RandomAccess interface</span></p></td><td><p><span>ArrayList implements RandomAccess(</span><span>Marker interface</span><span>) to indicate that they support fast random access (i.e. index based access) in java.</span></p></td><td><p><span>LinkedList does not implement RandomAccess interface in java.</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>AbstractList and AbstractSequentialList</span></p></td><td><p><span>ArrayList extends AbstractList (</span><span>abstract class</span><span>) which provides implementation to &nbsp;List interface </span><span>to minimize the effort required to implement this interface backed by RandomAccess interface</span><span>.</span></p></td><td><p><span>LinkedList extends AbstractSequentialList (</span><span>abstract class), AbstractSequentialList extends AbstractList.</span><span></span></p><p><span>In LinkedList, data is accessed sequentially, so for obtaining data at specific index, iteration is done on nodes sequentially in java.</span></p></td></tr><tr><td><p><span>7</span></p></td><td><p><span>How </span><span>get(index)</span><span> method works?</span></p><p><span>(Though difference has been discussed briefly in above 2 points but in this in point we will figure difference in detail.)</span></p></td><td><p><span>Get method of ArrayList directly gets element on specified index. </span><span>Hence, offering O(1) complexity in java.</span></p></td><td><p><span>Get method of LinkedList iterates on nodes sequentially to get element on specified index. </span><span>Hence, offering O(n) complexity in java.</span></p></td></tr><tr><td><p><span>8</span></p></td><td><p><span>When to use</span></p></td><td><p><span>Use ArrayList when get operations is more frequent than add and remove operations in java.</span></p></td><td><p><span>Use LinkedList when add and remove operations are more frequent than get operations in java.</span></p></td></tr></tbody></table>

Collection interview Question 5. What are differences between [ArrayList and Vector] in java?

Answer. Another very important collection framework interview question to differentiate between ArrayList and Vector in java.

<table><colgroup><col width="23"><col width="105"><col width="243"><col width="252"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.ArrayList</span></p></td><td><p><span>java.util.Vector</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>synchronization</span></p></td><td><p><span>java.util.ArrayList is </span><span>not synchronized </span><span>&nbsp;(because 2 threads on same ArrayList object can access it at same time).</span></p><p><span>I have created </span><a href="http://www.javamadesoeasy.com/2015/05/consequence-of-using-arraylist-in.html"><span>program</span></a><span> </span><span>to show consequence of using ArrayList in multithreading environment.</span></p><p><span>In the program we will implement our own arrayList in java.</span></p></td><td><p><span>java.util.Vector is </span><span>synchronized</span><span> (because 2 threads on same Vector object cannot &nbsp;access it at same time).</span></p><p><span>I have created </span><a href="http://www.javamadesoeasy.com/2015/05/advantage-of-using-vector-in.html"><span>program</span></a><span> </span><span>to show advantage of using Vector in multithreading environment.</span></p><p><span>In the program we will implement our own vector in java.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Performance</span></p></td><td><p><span>ArrayList is not synchronized, hence its operations are </span><span>faster </span><span>as compared to Vector in java.</span></p></td><td><p><span>Vector is synchronized, hence its operations are </span><span>slower </span><span>as compared to ArrayList in java.</span></p><p><span>If we are working not working in multithreading environment jdk recommends us to use ArrayList.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Enumeration</span></p></td><td><p><span>Enumeration </span><span>is </span><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>fail-fast</span></a><span>, means any modification made to ArrayList during iteration using Enumeration will throw </span><span>ConcurrentModificationException</span><span> in java.</span></p><br></td><td><p><span>Enumeration </span><span>is </span><span>fail-safe</span><span>, means any modification made to Vector during iteration using Enumeration don’t throw any exception in java.</span></p><br></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Introduced &nbsp;in which java version</span></p></td><td><p><span>ArrayList was introduced in second version of java i.e. </span><span>JDK 2.0</span></p></td><td><p><span>Vector was introduced in first version of java i.e. </span><span>JDK 1.0</span></p><p><span>But it was refactored in java 2 i.e. JDK 1.2 to implement the List interface, hence making it a member of member of the</span><a href="http://www.javamadesoeasy.com/2015/04/collection-in-java.html"><span> </span><span>Java Collections Framework</span></a><span>.</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Ensuring Capacity/ resizing.</span></p></td><td><p><span>ArrayList is created with initial capacity of 10.</span></p><p><span>When its full size is </span><span>increased by 50% </span><span>i.e. after resizing it’s size become 15 in java.</span></p></td><td><p><span>Vector is created with initial capacity of 10.</span></p><p><span>Vector’s size is </span><span>increased by 100% </span><span>i.e. after resizing it’s size become 20 in java.</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>Custom implementation</span></p></td><td><div dir="ltr"><p><a href="http://javamadesoeasy.com/2015/02/arraylist-custom-implementation.html"><span><img height="38px;" src="https://lh3.googleusercontent.com/2yHNtovknpsdxOKpK4Sd3oFiHP3fKhhrMsZDH3DJaRNsvWB7RnEqtXjyS5yrk6175OwELqF6-viscZQxK8uMK58-gmsz1tN0sHmVSJBEwKJ1UZwle61DItNZeF8MDwyFx-NUXHDU" width="188px;"></span></a><span>Read : </span><a href="http://javamadesoeasy.com/2015/02/arraylist-custom-implementation.html"><span>ArrayList custom implementation</span></a></p></div></td><td><p><a href="http://javamadesoeasy.com/2015/02/vector-custom-implementation.html"><span><img height="39px;" src="https://lh5.googleusercontent.com/Gm_SkaJR6TXlRpDt3ipjw739Gfcg4b2V-pMT4WWrw0cMVTsUhDvApjrvMATYF4XiBotrk8O0Sbc7kwi_v0V7SrrY_cfTUU5dR0_rEogBBG34UB1IviiWwIHcpc5XuH_k5KmOsnmP" width="166px;"></span></a><span>Read :</span></p><div dir="ltr"><p><a href="http://javamadesoeasy.com/2015/02/vector-custom-implementation.html"><span>Vector custom implementation</span></a></p></div></td></tr></tbody></table>

Collection interview Question 6. What are differences between [List and Set] interface in java?

Answer. Another very very important collection framework interview question to differentiate between List and Set in java.

<table><colgroup><col width="21"><col width="91"><col width="239"><col width="272"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.List</span></p></td><td><p><span>java.util.Set</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>Insertion order</span></p></td><td><p><span>java.util.List is ordered collection it </span><span>maintain insertion order</span><span> in java.</span></p></td><td><p><span>Most of the java.util.Set implementation </span><span>does not </span><span>maintain insertion order</span><span>.</span></p><p><span>HashSet does not maintains insertion order in java.</span></p><p><span><br></span><span>Thought LinkedHashSet maintains insertion order in java.</span></p><p><span>TreeSet is </span><span>sorted by natural order in java.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Duplicate elements</span></p></td><td><p><span>List </span><span>allows to store duplicate elements</span><span> in java.</span></p></td><td><p><span>Set does </span><span>not allow to store duplicate elements</span><span> in java</span><span>.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Null keys</span></p></td><td><p><span>List allows to store </span><span>many null keys</span><span> in java.</span></p></td><td><p><span>Most of the Set implementations allow to add only </span><span>one null</span><span> in java</span><span>.</span></p><p><span>TreeSet does not allow to add null in java.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Getting element on specific </span><span>index</span></p></td><td><p><span>List implementations provide get method to get element on specific index in java.</span></p><p><span>ArrayList, Vector, copyOnWriteArrayList and LinkedList provides -</span></p><p><span>get(int index)</span></p><p><span>Method returns element on specified </span><span>index</span><span>.</span></p><p><span>Get method directly gets element on specified index. </span><span>Hence, offering O(1) complexity.</span></p></td><td><p><span>Set implementations does not provide any such get method to get element on specified index in java.</span></p><br></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Implementing classes</span></p></td><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/arraylist-in-java.html"><span>ArrayList</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/linkedlist-in-java.html"><span>LinkedList</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/arraylist-vs-vector-similarity-and.html"><span>Vector</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/arraylist-vs-copyonwritearraylist.html"><span>CopyOnWriteArrayList</span></a><span> classes implements </span><a href="http://www.javamadesoeasy.com/2015/04/list-vs-set-similarity-and-differences.html"><span>List</span></a><span> interface in java.</span></p></div></td><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/hashset-in-java.html"><span>HashSet</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/hashset-vs-copyonwritearrayset.html"><span>CopyOnWriteArraySet</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/hashset-vs-linkedhashset-vs-treeset.html"><span>LinkedHashSet</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/hashset-vs-linkedhashset-vs-treeset.html"><span>TreeSet</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/treeset-vs-concurrentskiplistset.html"><span>ConcurrentSkipListSet</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/enumset-in-java-with-program.html"><span>EnumSet</span></a><span> classes implements </span><a href="http://www.javamadesoeasy.com/2015/04/list-vs-set-similarity-and-differences.html"><span>Set</span></a><span> interface in java.</span></p></div></td></tr><tr><td><p><span>6</span></p></td><td><p><span>listIterator</span></p></td><td><p><span>listIterator </span><span>method returns listIterator to iterate over elements in List in java.</span></p><p><span>listIterator provides </span><span>additional methods as compared to iterator like</span></p><p><span>hasPrevious(), previous(), nextIndex(), previousIndex(), add(E element), set(E element)</span></p></td><td><p><span>Set does not provide anything like listIterator. It simply return Iterator in java.</span></p></td></tr><tr><td><p><span>7</span></p></td><td><p><span>Structure and resizable</span></p></td><td><p><span>List</span><span> are Resizable-array implementation of the java.util.</span><span>List</span><span> interface in java.</span></p></td><td><p><span>Set uses </span><a href="http://www.javamadesoeasy.com/2015/04/map-hierarchy-in-java-detailed-hashmap.html"><span>Map</span></a><span> </span><span>for their implementation.</span></p><p><span>Hence, structure is map based and resizing depends on Map implementation.</span></p><div dir="ltr"><p><span>Example &gt; </span><a href="http://www.javamadesoeasy.com/2015/04/hashset-in-java.html"><span>HashSet</span></a><span> internally uses </span><a href="http://javamadesoeasy.com/2015/02/hashmap-custom-implementation.html"><span>HashMap</span></a><span>.</span></p></div></td></tr><tr><td><p><span>8</span></p></td><td><p><span>Index based structure /RandomAccess</span></p></td><td><p><span>As </span><span>ArrayList</span><span> uses array for implementation it is index based structure, hence provides random access to elements.</span></p><p><span>But </span><a href="http://www.javamadesoeasy.com/2015/04/linkedlist-in-java.html"><span>LinkedList</span></a><span> is not indexed based structure in java.</span></p></td><td><p><span>Set is not index based structure at all in java.</span></p></td></tr></tbody></table>

Answer. This collection framework interview question is tests your knowledge of iterating over different collection framework classes in java.

<table><colgroup><col width="21"><col width="419"><col width="185"></colgroup><tbody><tr><td><br></td><td><p><span>java.util.ListIterator</span></p></td><td><p><span>java.util.Iterator</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>hasPrevious()</span><span> </span><span>&nbsp;method returns true if this listIterator has more elements when traversing the list in the reverse direction.</span></p></td><td><p><span>No such method </span><span>in java.util.Iterator.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>previous()</span><span> </span><span>&nbsp;returns previous element in iteration (traversing in backward direction).</span></p><p><span>if the iteration has no previous elements than </span><span>NoSuchElementException </span><span>is thrown.</span></p></td><td><p><span>No such method </span><span>in java.util.Iterator.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>nextIndex()</span><span> &nbsp;method returns the index of the element that would be returned by a subsequent call to next() method. If listIterator is at the end of the list than method returns size of list.</span></p></td><td><p><span>No such method </span><span>in java.util.Iterator.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>previousIndex()</span><span> &nbsp;method returns the index of the element that would be returned by a subsequent call to previous() method. If listIterator is at the start of the list than method returns -1.</span></p></td><td><p><span>No such method </span><span>in java.util.Iterator.</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>add(E element)</span></p><p><span>Method inserts the specified </span><span>element </span><span>into the list.</span></p><p><span>The element is inserted immediately before the element that would be returned by next </span><span>(So, subsequent call to next would be unaffected)</span><span>, if any, and after the element that would be returned by previous </span><span>(So,subsequent call to previous would return the new</span><span> </span><span>element</span><span>)</span><span>, if any.</span></p><p><span>If the list does not contain any element than new </span><span>element </span><span>will be the sole element in the list.</span></p></td><td><p><span>No such method </span><span>in java.util.Iterator.</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>set(E element)</span></p><p><span>Method replaces the last element returned by next() or previous() method with the specified </span><span>element</span><span>. This call can be made only if neither remove nor add have been called after the last call to next or previous.</span></p><p><span>If call to set() method is followed up by any call made to remove() or add() method after next() or previous() than </span><span>UnsupportedOperationException </span><span>is thrown.</span></p></td><td><p><span>No such method </span><span>in java.util.Iterator.</span></p></td></tr><tr><td><p><span>7</span></p></td><td><div dir="ltr"><p><span>All the implementations of </span><a href="http://www.javamadesoeasy.com/2015/04/list-hierarchy-in-java-detailed.html"><span>List</span></a><span> interface like </span><a href="http://www.javamadesoeasy.com/2015/04/arraylist-in-java.html"><span>ArrayList</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/linkedlist-in-java.html"><span>LinkedList</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/arraylist-vs-vector-similarity-and.html"><span>Vector</span></a><span>, </span><a href="http://www.javamadesoeasy.com/2015/04/arraylist-vs-copyonwritearraylist.html"><span>CopyOnWriteArrayList</span></a><span> classes returns listIterator.</span></p></div></td><td><p><span>All Implementation classes of </span><a href="http://www.javamadesoeasy.com/2015/04/collection-in-java.html"><span>Collection</span></a><span> interface’s subinterfaces like </span><a href="http://www.javamadesoeasy.com/2015/04/list-vs-set-similarity-and-differences.html"><span>Set and List</span></a><span> return iterator.</span></p></td></tr></tbody></table>

Answer.  This is another very important collection framework interview question.In real projects you must have used both Collection and Collections but what is the difference between two of them in java?

java.util.[Collection]  is the root interface in the hierarchy of Java Collection framework.

The JDK does not provide any classes which directly implements java.util.Collection interface, but it  provides classes such as [ArrayList](http://www.javamadesoeasy.com/2015/04/arraylist-in-java.html), [LinkedList](http://www.javamadesoeasy.com/2015/04/linkedlist-in-java.html), [vector](http://www.javamadesoeasy.com/2015/04/arraylist-vs-vector-similarity-and.html), [HashSet](http://www.javamadesoeasy.com/2015/04/hashset-in-java.html), [EnumSet](http://www.javamadesoeasy.com/2015/04/enumset-in-java-with-program.html), [LinkedHashSet](http://www.javamadesoeasy.com/2015/04/hashset-vs-linkedhashset-vs-treeset.html), [TreeSet](http://www.javamadesoeasy.com/2015/04/hashset-vs-linkedhashset-vs-treeset.html), [CopyOnWriteArrayList](http://www.javamadesoeasy.com/2015/04/arraylist-vs-copyonwritearraylist.html), [CopyOnWriteArraySet](http://www.javamadesoeasy.com/2015/04/hashset-vs-copyonwritearrayset.html), [ConcurrentSkipListSet](http://www.javamadesoeasy.com/2015/04/treeset-vs-concurrentskiplistset.html)  which implements more specific subinterfaces like [Set and List](http://www.javamadesoeasy.com/2015/04/list-vs-set-similarity-and-differences.html) in java.

java.util.Collections is a utility class which consists of static methods that operate on or return Collection in java.

java.util.Collections provides method like >

-   reverse method for reversing [List](http://www.javamadesoeasy.com/2015/04/list-hierarchy-in-java-detailed.html) in java.
    
-   shuffle method for shuffling elements of List in java.
    

-   min method to return smallest element in Collection in java.
    
-   max method to return smallest element in Collection.
    
-   sort method for sorting List.
    

Additionally you must know that java.util.Collection and java.util.Collections both were introduced in second version of java i.e. in JDK 2.0.

Collection interview Question 9. What are core classes and interfaces in java.util.List hierarchy in java?

Answer. Freshers must know core classes in List hierarchy but experienced developers must be able to explain this java.util.List hierarchy in detail.

[![](https://lh4.googleusercontent.com/qDeQGjnXr6NSTwnS-TgcG-I_rqIYbecxyA6f6GL-Ci00Y3Q1f5PwQlLXMSOMO9UEmQvXD7qc9gGNMnHLtGngJhqgFNJ60eEn1djQ6KBxqGLjkVGia4ZN9HUkl436Um71_pdK5Qk)](http://www.javamadesoeasy.com/2015/04/list-hierarchy-in-java-detailed.html)

java.util.[List](http://www.javamadesoeasy.com/2015/04/list-vs-set-similarity-and-differences.html) interface extends java.util.Collection interface.

Also some abstract classes like java.util.AbstractCollection, java.util.AbstractList and java.util.AbstractSequentialList have been mentioned in hierarchy.

Collection interview Question 10. What are core classes and interfaces in java.util.Set hierarchy?

Answer. Freshers must know core classes in Set hierarchy but experienced developers must be able to explain this java.util.Set hierarchy in detail.

[![](https://lh3.googleusercontent.com/G0YGIl7za1jmJBgBFHUV7djf6oPadSwYCu3nxwTz_XK6xS1e99QTgOKUlBigkLvqmk2Q8S0aOA3m3lsuf1J6xi2ey5qjBiU1_gxCSH8svfandQ6uNXXEbhc_QB_UHcy4ms1T4sg)](http://www.javamadesoeasy.com/2015/04/set-hierarchy-in-java-detailed-hashset.html)

java.util.[Set](http://www.javamadesoeasy.com/2015/04/list-vs-set-similarity-and-differences.html) interface extends java.util.Collection interface.

Also some abstract classes like java.util.Dictionary and java.util.AbstractSet and java.util.AbstractCollection have been mentioned in hierarchy.

Collection interview Question 11. What are core classes and interfaces in java.util.Map hierarchy?

Answer. Freshers must know core classes in Map hierarchy but experienced developers must be able to explain this java.util.Map hierarchy in detail.

[![](https://lh6.googleusercontent.com/d_rG36rhkALZ9qxXyANAvQsLazSQg4Pok9HJEmPqS5EY18bJAIOy94HsM-3LNifbkdCEkCIpUH29ev3jU2LoP6Ti4n1tZ12xJO906NJYZauGugZ6Pe78_pZGYv53E4CGeGsyXL4)](http://www.javamadesoeasy.com/2015/04/map-hierarchy-in-java-detailed-hashmap.html)

java.util.Map interface extends java.util.Collection interface.

Also some abstract classes like java.util.Dictionary and java.util.AbstractMap have been mentioned in hierarchy.

Answer. Experienced developers must be well versed to answer this collection framework interview question in java.

Differences between java.util.Iterator and java.util.Enumeration in java \>

<table><colgroup><col width="20"><col width="133"><col width="232"><col width="237"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.Enumeration</span></p></td><td><p><span>java.util.Iterator</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>Remove elements during iteration</span></p></td><td><p><span>java.util.Enumeration </span><span>doesn’t allows </span><span>to remove elements from collection during iteration in java.</span></p></td><td><p><span>java.util.Iterator </span><span>allows </span><span>to remove elements from collection during iteration by using </span><span>remove()</span><span> method in java.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Improved naming conventions in Iterator</span></p></td><td><p><span>nextElement()</span></p><p><span>Method Returns the next element of this enumeration if this enumeration object has at least one more element to provide.</span></p><p><span>hasMoreElements()</span></p><p><span>returns true if enumeration contains more elements.</span></p></td><td><p><span>nextElement() </span><span>has been changed to </span><span>next()</span><span> in Iterator.</span></p><p><span>And</span></p><p><span>hasMoreElements() </span><span>has been changed to </span><span>hasNext() </span><span>in Iterator.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Introduced in</span></p><p><span>which java</span></p><p><span>version</span></p></td><td><p><span>Enumeration was introduced in first version</span></p><p><span>of java i.e. </span><span>JDK 1.0</span></p></td><td><p><span>Iterator was introduced in second version</span></p><p><span>of java i.e. </span><span>JDK 2.0</span></p><p><span>Iterator was introduced to replace Enumeration in the Java Collections Framework.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Recommendation</span></p></td><td><p><span>Java docs </span><span>recommends iterator over enumeration</span><span>.</span></p></td><td><p><span>Java docs </span><span>recommends iterator over enumeration</span><span>.</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Enumeration and Iterator over </span><a href="http://www.javamadesoeasy.com/2015/04/arraylist-vs-vector-similarity-and.html"><span>Vector</span></a></p></td><td><p><span>Enumeration </span><span>returned by Vector is </span><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>fail-safe</span></a><span>, means any modification made to Vector during iteration using Enumeration don’t throw any exception in java.</span></p></td><td><p><span>Iterator </span><span>returned by </span><span>Vector </span><span>are </span><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>fail-fast</span></a><span>,</span><span> means any structural modification made to ArrayList during iteration will throw </span><span>ConcurrentModificationException </span><span>&nbsp;in java.</span></p></td></tr></tbody></table>

### For more detail read : [Iterator vs Enumeration - Differences and similarities in java](http://www.javamadesoeasy.com/2015/04/iterator-vs-enumeration-differences-and.html)

Collection interview Question 13. How do we override equals and hashcode method in java, write a code to use Employee as key in HashMap in java? (Important)

Answer.  This is one of the most important collection framework interview question in java. Prepare for this question properly. Freshers must know the concept how to override equals and hashcode method but experienced developers must be able to write the java code to override equals and hashcode neatly. We will override equals() and hashCode() like this -

By overriding equals() and hashCode() method we could use custom object as key in HashMap.

1)  Check whether obj is null or not.

  if(obj==null) //If obj is null, return without comparing obj & Employee class.

2)  check whether  obj is instance of Employee class or not.

if(this.getClass()!=obj.getClass()) //identifies whether obj is instance of Employee class or not.

3) Then, type cast obj into employee instance.

 Employee emp=(Employee)obj;  //type cast obj into employee instance.

<table><colgroup><col width="624"></colgroup><tbody><tr><td><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>@Override</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>public</span><span> </span><span>boolean</span><span> </span><span>equals</span><span>(Object obj){</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>if</span><span>(obj==</span><span>null</span><span>)</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>return</span><span> </span><span>false</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>if</span><span>(</span><span>this</span><span>.getClass()!=obj.getClass())</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>return</span><span> </span><span>false</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>Employee emp=(Employee)obj;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>return</span><span> (emp.</span><span>id</span><span>==</span><span>this</span><span>.</span><span>id</span><span> || emp.</span><span>id</span><span>.equals(</span><span>this</span><span>.</span><span>id</span><span>))</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>&amp;&amp; (emp.</span><span>name</span><span>==</span><span>this</span><span>.</span><span>name</span><span> || emp.</span><span>name</span><span>.equals(</span><span>this</span><span>.</span><span>name</span><span>)); &nbsp;&nbsp;</span><span><span> </span></span><span>&nbsp;&nbsp;</span><span><span></span></span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>}</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>@Override</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>public</span><span> </span><span>int</span><span> </span><span>hashCode</span><span>(){</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>int</span><span> hash=(</span><span>this</span><span>.</span><span>id</span><span>==</span><span>null</span><span> ? 0: </span><span>this</span><span>.</span><span>id</span><span>.hashCode() ) +</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>(</span><span>this</span><span>.</span><span>name</span><span>==</span><span>null</span><span> ? 0: </span><span>this</span><span>.</span><span>name</span><span>.hashCode() );</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>return</span><span> hash; &nbsp;&nbsp;&nbsp;&nbsp;</span><span><span></span></span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>}</span></p><br></td></tr></tbody></table>

Let’s say in an organisation there exists a employee with id=1 and name=’sam’     and some data is stored corresponding to him, but if modifications have to be made in data, previous data must be overridden.

Collection interview Question 14. What classes should i prefer to use a key in HashMap in java? (Important)

Answer. This collection framework interview question will check your in depth knowledge of Java’s Collection Api’s. we should prefer String, Integer, Long, Double, Float, Short and any other wrapper class. Reason behind using them as a key is that they override equals() and hashCode() method, we need not to write any explicit code for overriding equals() and hashCode() method in java.

Let’s use Integer class as key in HashMap(Example) -

<table><colgroup><col width="624"></colgroup><tbody><tr><td><p><span>import</span><span> java.util.HashMap;</span></p><p><span>import</span><span> java.util.Map;</span></p><p><span>public</span><span> </span><span>class</span><span> StringInMapExample {</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>public</span><span> </span><span>static</span><span> </span><span>void</span><span> main(String...a){</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>//HashMap's key=Integer class &nbsp;(Integer’s api has already overridden </span><span>hashCode()</span><span> and equals() method for us )</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>Map&lt;Integer, String&gt; hm=</span><span>new</span><span> HashMap&lt;Integer, String&gt;();</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>hm.put(1, </span><span>"data"</span><span>);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>hm.put(1, </span><span>"data OVERRIDDEN"</span><span>);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>System.</span><span>out</span><span>.println(hm.get(1));</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>}</span></p><p><span>}</span></p><p><span>/*OUTPUT</span></p><p><span>data OVERRIDDEN</span></p><p><span>*/</span></p></td></tr></tbody></table>

If, we note above program, what we will see is we didn’t override equals() and hashCode() method, but still we were able to store data in HashMap, override data and retrieve data using get method.

\>Let’s check in Integer’s API, how Integer class has overridden equals() and hashCode() method :  

<table><colgroup><col width="424"></colgroup><tbody><tr><td><p><span>public</span><span> </span><span>int</span><span> </span><span>hashCode</span><span>() {</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>value</span><span>;</span></p><p><span><span></span></span><span>}</span></p><p><span>public</span><span> </span><span>boolean</span><span> </span><span>equals</span><span>(Object obj) {</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>if</span><span> (obj </span><span>instanceof</span><span> Integer) {</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>return</span><span> </span><span>value</span><span> == ((Integer)obj).intValue();</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>false</span><span>;</span></p><p><span><span></span></span><span>}</span></p></td></tr></tbody></table>

Collection interview Question 15. What are differences between [HashMap and Hashtable](http://www.javamadesoeasy.com/2015/04/hashmap-and-hashtable-similarity-and.html) in java?

Answer. Fresher and Experienced developers must answer this important collection framework interview question in detail in java.

Differences between java.util.[HashMap](http://www.javamadesoeasy.com/2015/04/hashmap-in-java.html) and java.util.Hashtable in java >

<table><colgroup><col width="20"><col width="115"><col width="237"><col width="252"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.HashMap</span></p></td><td><p><span>java.util.Hashtable</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>synchronization</span></p></td><td><p><span>java.util.HashMap is </span><span>not synchronized </span><span>&nbsp;(because 2 threads on same HashMap object can access it at same time) in java.</span></p><br></td><td><p><span>java.util.Hashtable is </span><span>synchronized</span><span> (because 2 threads on same Hashtable object cannot access it at same time) in java.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Performance</span></p></td><td><p><span>HashMap is not synchronized, hence its operations are </span><span>faster </span><span>as compared to Hashtable in java.</span></p></td><td><p><span>Hashtable is synchronized, hence its operations are </span><span>slower </span><span>as compared to HashMap in java.</span></p><p><span>If we are working not working in multithreading environment jdk recommends us to use HashMap.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Null keys and values</span></p></td><td><p><span>HashMap allows to store </span><span>one null key</span><span> and </span><span>many null values </span><span>i.e. many keys can have null value in java.</span></p></td><td><p><span>Hashtable does </span><span>not allow to store null key or null value</span><span>.</span></p><p><span>Any attempt to store null key or value throws runtimeException (</span><span>NullPointerException)</span><span> in java.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Introduced &nbsp;in which java version</span></p></td><td><p><span>HashMap was introduced in second version of java i.e. </span><span>JDK 2.0</span></p></td><td><p><span>Hashtable was introduced in first version of java i.e. </span><span>JDK 1.0</span></p><p><span>But it was refactored in java 2 i.e. JDK 1.2 to implement the Map interface, hence making it a member of member of the</span><a href="http://download.oracle.com/javase/7/docs/technotes/guides/collections/index.html"><span> </span><span>Java Collections Framework</span></a><span>.</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Recommendation</span></p></td><td><p><span>In non-multithreading environment it is recommended to use HashMap than using Hashtable in java.</span></p></td><td><p><span>I</span><span>n java 5 i.e. JDK 1.5</span><span>, it is </span><span>recommended </span><span>to use </span><a href="http://www.javamadesoeasy.com/2015/04/concurrenthashmap-in-java.html"><span>ConcurrentHashMap</span></a><span> than using Hashtable.</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>Extends Dictionary </span><span>(Abstract class, which is obsolete)</span></p></td><td><p><span>HashMap does not extends Dictionary in java.</span></p></td><td><p><span>Hashtable extends Dictionary </span><span>(which maps non-null keys to values. In a given Dictionary we can look up value corresponding to key) in java.</span></p></td></tr></tbody></table>

Answer. Another very important collection framework interview question to differentiate between following Set implementations in java.

Differences between java.util.[HashSet](http://www.javamadesoeasy.com/2015/04/hashset-in-java.html) vs java.util.LinkedHashSet vs java.util.TreeSet in java>

<table><colgroup><col width="27"><col width="91"><col width="159"><col width="183"><col width="165"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.HashSet</span></p></td><td><p><span>java.util.LinkedHashSet</span></p></td><td><p><span>java.util.TreeSet</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>Insertion order</span></p></td><td><p><span>java.util.HashSet does not maintains insertion order in java.</span></p><p><span>Example in java &gt;</span></p><p><span>set.add(</span><span>"b"</span><span>);</span></p><p><span>set.add(</span><span>"c"</span><span>);</span></p><p><span>set.add(</span><span>"a"</span><span>);</span></p><p><span>Output &gt;</span><span> &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p><span>No specific order</span></p></td><td><p><span>java.util.LinkedHashSet maintains insertion order in java.</span></p><p><span>Example in java &gt;</span></p><p><span>set.add(</span><span>"b"</span><span>);</span></p><p><span>set.add(</span><span>"c"</span><span>);</span></p><p><span>set.add(</span><span>"a"</span><span>);</span></p><p><span>Output &gt;</span><span> &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p><span>b</span></p><p><span>c</span></p><p><span>a</span></p></td><td><p><span>java.util.TreeSet is </span><span>sorted by natural order in java.</span></p><p><span>Example in java &gt;</span></p><p><span>set.add(</span><span>"b"</span><span>);</span></p><p><span>set.add(</span><span>"c"</span><span>);</span></p><p><span>set.add(</span><span>"a"</span><span>);</span></p><p><span>Output &gt;</span><span> &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p><span>a</span></p><p><span>b</span></p><p><span>c</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Null elements</span></p></td><td><p><span>HashSet allows to store </span><span>one null</span><span> in java</span><span>.</span></p></td><td><p><span>LinkedHashSet allows to store </span><span>one null</span><span> in java.</span></p></td><td><p><span>TreeSet does </span><span>not </span><span>allows to store </span><span>any null</span><span> in java.</span></p><p><span>Any attempt to add null throws runtimeException (</span><span>NullPointerException</span><span>).</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Data structure internally used for storing data</span></p></td><td><p><span>For storing elements HashSet internally uses HashMap.</span></p></td><td><p><span>For storing elements LinkedHashSet internally uses &nbsp;LinkedHashMap.</span></p></td><td><p><span>For storing elements TreeSet internally uses TreeMap.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Introduced &nbsp;in which java version</span></p></td><td><p><span>java.util.HashSet was introduced in second version of java (1.2) i.e. </span><span>JDK 2.0</span></p></td><td><p><span>java.util.LinkedHashSet was introduced in second version of java (1.4) i.e. </span><span>JDK 4.0</span></p></td><td><p><span>java.util.TreeSet was introduced in second version of java (1.2) i.e. </span><span>JDK 2.0</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Implements which interface</span></p></td><td><p><span>HashSet implements </span><span>java.util.</span><a href="http://www.javamadesoeasy.com/2015/04/set-hierarchy-in-java-detailed-hashset.html"><span>Set</span></a><span> </span><span>interface.</span></p></td><td><p><span>LinkedHashSet implements </span><span>java.util.Set </span><span>interface.</span></p></td><td><p><span>TreeSet implements </span><span>java.util.Set</span></p><p><span>java.util.SortedSet</span></p><p><span>java.util.NavigableSet</span><span> interface.</span></p></td></tr></tbody></table>

Answer. Take my words java developers won’t be able to get away from this very important collection framework interview question.

<table><colgroup><col width="87"><col width="265"><col width="272"></colgroup><tbody><tr><td><p><span>Property</span></p></td><td><p><span>java.util.</span><span>HashMap</span></p></td><td><p><span>java.util.concurrent. </span><span>ConcurrentHashMap</span><span></span></p></td></tr><tr><td><p><span>synchronization</span></p></td><td><p><span>HashMap is </span><span>not synchronized.</span></p></td><td><p><span>ConcurrentHashMap is </span><span>synchronized</span><span>.</span></p></td></tr><tr><td><p><span>2 threads on same Map object can access it at concurrently?</span></p></td><td><p><span>Yes, because HashMap is not synchronized</span><span>.</span></p></td><td><p><span>Yes.</span></p><p><span>But how despite of being synchronized, 2 threads on same </span><span>ConcurrentHashMap </span><span>object can access it at same time?</span></p><p><span>ConcurrentHashMap </span><span>is divided into different </span><span>segments </span><span>based on concurrency level. So different threads can access different </span><span>segments </span><span>concurrently.</span></p></td></tr><tr><td><p><span>Performance</span></p></td><td><p><span>We will </span><span>synchronize HashMap and then compare its performance with ConcurrentHashMap</span><span>.</span></p><p><span>We can synchronize hashMap by using Collections’s class </span><span>synchronizedMap </span><span>method.</span></p><div dir="ltr"><table><colgroup><col width="286"></colgroup><tbody><tr><td><p><span>Map synchronizedMap = Collections.</span><span>synchronizedMap</span><span>(hashMap);</span></p></td></tr></tbody></table></div><p><span>Now, no 2 threads can access same instance of map concurrently.</span></p><p><span>Hence synchronized HashMap’s performance is slower as compared to ConcurrentHashMap.</span></p><p><span>But why we didn’t compared HashMap (unSynchronized) with ConcurrentHashMap?</span></p><p><span>Because performance of unSynchronized collection is always better than some synchronized collection. As, default (unSynchronized) hashMap didn’t cause any locking.</span></p></td><td><p><span>ConcurrentHashMap’s performance is faster as compared to HashMap (</span><span>because it is divided into segments, as discussed in above point</span><span>).</span></p><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/hashmap-and-concurrenthashmap.html"><span>Read this post for performance comparison between HashMap and ConcurrentHashMap.</span></a></p></div></td></tr><tr><td><p><span>Null keys and values</span></p></td><td><p><span>HashMap allows to store </span><span>one null key</span><span> and </span><span>many null values </span><span>i.e. any key can have null value.</span></p></td><td><p><span>ConcurrentHashMap does </span><span>not allow to store null key or null value</span><span>.</span></p><p><span>Any attempt to store null key or value throws runtimeException (</span><span>NullPointerException)</span><span>.</span></p></td></tr><tr><td><p><span>iterators</span></p></td><td><p><span>The iterators returned by the iterator() method of HashMap are </span><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>fail-fast </span></a><span>&gt;</span></p><p><span>hashMap.keySet().iterator()</span></p><p><span>hashMap.values().iterator()</span></p><p><span>hashMap.entrySet().iterator()</span></p><p><span>all three iterators are </span><span>fail-fast</span></p></td><td><div dir="ltr"><p><span>iterators are </span><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>fail-safe</span></a><span>.</span></p></div><p><span>concurrentHashMap.keySet().iterator()</span></p><p><span>concurrentHashMap.values().iterator()</span></p><p><span>concurrentHashMap.entrySet().iterator()</span></p><p><span>all three iterators are </span><span>fail-safe.</span></p></td></tr><tr><td><p><span>putIfAbsent</span></p></td><td><p><span>HashMap does not contain putIfAbsent method.</span></p><p><span>putIfAbsent </span><span>method is equivalent to writing following code &gt;</span></p><br><div dir="ltr"><table><colgroup><col width="251"></colgroup><tbody><tr><td><p><span>synchronized</span><span> (map){</span></p><p><span>&nbsp;&nbsp;&nbsp;</span><span>if</span><span> (!</span><span>map</span><span>.containsKey(key))</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>return</span><span> </span><span>map</span><span>.put(key, value);</span></p><p><span>&nbsp;&nbsp;&nbsp;</span><span>else</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>return</span><span> </span><span>map</span><span>.get(key);</span></p><p><span>}</span></p></td></tr></tbody></table></div><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/program-to-create-method-that-provides.html"><span>Program to create method that provides functionality similar to putIfAbsent method of ConcurrentHashMap and to be used with HashMap</span></a></p></div></td><td><p><span>If map does not contain specified </span><span>key</span><span>, put specified </span><span>key-value </span><span>pair in map and return null.</span></p><p><span>If map already contains specified </span><span>key</span><span>, return value corresponding to specified </span><span>key</span><span>.</span></p><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/program-to-use-concurrenthashmaps.html"><span>Program to use ConcurrentHashMap’s putIfAbsent method</span></a></p></div></td></tr><tr><td><p><span>Introduced &nbsp;in which java version</span></p></td><td><p><span>HashMap was introduced in </span><span>java 2 i.e. JDK 1.2</span><span>,</span></p></td><td><p><span>ConcurrentHashMap was introduced in </span><span>java 5 </span><span>i.e.</span><span> JDK 1.5</span><span>, since its introduction Hashtable has become obsolete, because of concurrency level its performance is better than Hashtable.</span></p></td></tr><tr><td><p><span>Implements which interface</span></p></td><td><p><span>HashMap implements </span><span>java.util.</span><a href="http://www.javamadesoeasy.com/2015/04/map-hierarchy-in-java-detailed-hashmap.html"><span>Map</span></a></p></td><td><p><span>ConcurrentHashMap implements</span></p><p><span>java.util.Map </span><span>and</span></p><p><span>java.util.concurrent.ConcurrentMap</span></p></td></tr><tr><td><p><span>Package</span></p></td><td><p><span>HashMap is in </span><span>java.util</span><span> package</span></p></td><td><p><span>ConcurrentHashMap is in </span><span>java.util.concurrent </span><span>package.</span></p></td></tr></tbody></table>

Answer. Another important collection framework interview question

to differentiate between following Map implementations in java.

Differences between java.util.[HashMap](http://www.javamadesoeasy.com/2015/04/hashmap-in-java.html) vs java.util.[Hashtable](http://www.javamadesoeasy.com/2015/04/hashmap-and-hashtable-similarity-and.html) vs java.util.LinkedHashMap vs java.util.[TreeMap](http://www.javamadesoeasy.com/2015/04/treemap-vs-concurrentskiplistmap.html) >

<table><colgroup><col width="21"><col width="84"><col width="99"><col width="113"><col width="159"><col width="148"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>HashMap</span></p></td><td><p><span>Hashtable</span></p></td><td><p><span>LinkedHashMap</span></p></td><td><p><span>TreeMap</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>Insertion order</span></p></td><td><p><span>HashMap does not maintains insertion order in java.</span></p></td><td><p><span>Hashtable does not maintains insertion order in java.</span></p></td><td><p><span>LinkedHashMap &nbsp;maintains insertion order in java.</span></p></td><td><p><span>TreeMap is sorted by natural order of keys in java.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Performance</span></p></td><td><p><span>HashMap is not synchronized, hence its operations are </span><span>faster </span><span>as compared to Hashtable.</span></p></td><td><p><span>Hashtable is synchronized, hence its operations are </span><span>slower </span><span>as compared HashMap.</span></p><p><span>If we are working not working in multithreading environment jdk recommends us to use HashMap.</span></p></td><td><p><span>LinkedHashMap must be used only when we want to maintain insertion order. </span><span>Time and space overhead</span><span> is there because for maintaining order it internally uses </span><span>Doubly Linked list</span><span>.</span></p></td><td><p><span>TreeMap must be used only when we want sorting based on natural order. Otherwise sorting operations cost performance. (Comparator is called for sorting purpose)</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Null keys and values</span></p></td><td><p><span>HashMap allows to store </span><span>one null key</span><span> and </span><span>many null values </span><span>i.e. many keys can have null value in java.</span></p></td><td><p><span>Hashtable does </span><span>not allow to store null key or null value</span><span>.</span></p><p><span>Any attempt to store null key or value throws runtimeException (</span><span>NullPointerException)</span><span> in java.</span></p></td><td><p><span>LinkedHashMap allows to store </span><span>one null key</span><span> and </span><span>many null values </span><span>i.e. any key can have null value in java.</span></p></td><td><p><span>TreeMap does </span><span>not allow to store null key but allow many null values</span><span>.</span></p><p><span>Any attempt to store null key throws runtimeException (</span><span>NullPointerException)</span><span> in java.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Implements which interface</span></p></td><td><p><span>HashMap implements </span><span>java.util.</span><a href="http://www.javamadesoeasy.com/2015/04/map-hierarchy-in-java-detailed-hashmap.html"><span>Map</span></a></p></td><td><p><span>Hashtable implements </span><span>java.util.Map</span></p></td><td><p><span>LinkedHashMap implements </span><span>java.util.Map</span></p></td><td><p><span>TreeMap implements</span></p><p><span>java.util.Map</span></p><p><span>java.util.SortedMap</span></p><p><span>java.util.NavigableMap</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Implementation uses?</span></p></td><td><div dir="ltr"><p><span>HashMap use </span><a href="http://javamadesoeasy.com/2015/02/hashmap-custom-implementation.html"><span>buckets</span></a></p></div></td><td><p><span>Hashtable use </span><span>buckets</span></p></td><td><div dir="ltr"><p><span>LinkedHashMap uses </span><a href="http://www.javamadesoeasy.com/2015/02/linkedhashmap-custom-implementation.html"><span>doubly linked lists</span></a></p></div></td><td><p><span>TreeMap uses </span><span>Red black tree</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>Complexity of put, get and remove methods</span></p></td><td><p><span>O(1)</span></p></td><td><p><span>O(1)</span></p></td><td><p><span>O(1)</span></p><p><span>overhead</span><span> of updating </span><span>Doubly Linked list</span><span> for maintaining order it internally uses.</span></p></td><td><p><span>O(log(n))</span></p></td></tr><tr><td><p><span>7</span></p></td><td><p><span>Extends java.util.</span><span>Dictionary </span><span>(Abstract class, which is obsolete)</span></p></td><td><p><span>HashMap </span><span>doesn’t </span><span>extends Dictionary.</span></p></td><td><p><span>Hashtable </span><span>extends </span><span>Dictionary </span><span>(which maps non-null keys to values. In a given Dictionary we can look up value corresponding to key)</span></p></td><td><p><span>LinkedHashMap </span><span>doesn’t </span><span>extends Dictionary.</span></p></td><td><p><span>TreeMap </span><span>doesn’t </span><span>extends Dictionary.</span></p></td></tr><tr><td><p><span>8</span></p></td><td><p><span>Introduced in which java version?</span></p></td><td><p><span>HashMap was introduced in second version of java i.e. </span><span>JDK 2.0</span></p></td><td><p><span>Hashtable was introduced in first version of java i.e. </span><span>JDK 1.0</span></p><p><span>But it was refactored in java 2 i.e. JDK 1.2 to implement the Map interface, hence making it a member of member of the</span><a href="http://download.oracle.com/javase/7/docs/technotes/guides/collections/index.html"><span> </span><span>Java Collections Framework</span></a><span>.</span></p></td><td><p><span>LinkedHashMap was introduced in fourth version of java i.e. </span><span>JDK 4.0</span></p></td><td><p><span>TreeMap was introduced in second version of java i.e. </span><span>JDK 2.0</span></p></td></tr></tbody></table>

Answer. This is tricky and complex collection framework interview question for experienced developers in java.

<table><colgroup><col width="20"><col width="131"><col width="221"><col width="251"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.HashMap</span></p></td><td><p><span>java.util.IdentityHashMap</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>Keys comparison &nbsp;</span><span>&nbsp;object-equality &nbsp;vs reference-equality</span></p></td><td><p><span>HashMap</span><span> when comparing keys (and values) performs object-equality not reference-equality. In an HashMap, two keys k1 and k2 are equal if and only if (k1==null ? k2==null : k1.equals(k2))</span></p></td><td><p><span>IdentityHashMap</span><span> when comparing keys (and values) performs reference-equality in place of object-equality. In an IdentityHashMap, two keys k1 and k2 are equal if and only if (k1==k2)</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Initial size</span></p></td><td><p><span>Constructs a new HashMap, Its initial capacity is 16 in java.</span></p><div dir="ltr"><table><colgroup><col width="*"></colgroup><tbody><tr><td><p><span>new</span><span> HashMap();</span></p></td></tr></tbody></table></div></td><td><p><span>Constructs a new IdentityHashMap, with maximum size of 21 in java.</span></p><div dir="ltr"><table><colgroup><col width="*"></colgroup><tbody><tr><td><p><span>new</span><span> IdentityHashMap();</span></p></td></tr></tbody></table></div></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Introduced in which java version</span></p></td><td><p><span>HashMap was introduced in second version of java i.e. </span><span>JDK 2.0</span></p></td><td><p><span>IdentityHashMap was introduced in fourth version of java i.e. </span><span>JDK 4.0</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Program</span></p></td><td><p><span>Program 1 shows &gt;</span><span><br></span><span>comparing keys (and values) performs object-equality in place of reference-equality . In an HashMap, two keys k1 and k2 are equal if and only if</span><span> (k1==null ? k2==null : k1.equals(k2)).</span></p></td><td><p><span>Program 2 shows &gt;</span></p><p><span>comparing keys (and values) performs reference-equality in place of object-equality. In an IdentityHashMap, two keys k1 and k2 are equal if and only if </span><span>(k1==k2).</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>overridden equals() and hashCode() method call?</span></p></td><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/02/override-equals-and-hashcode-method.html"><span>overridden equals() and hashCode() method</span></a><span> </span><span>are called when put, get methods are called in </span><span>HashMap</span><span>.</span></p></div><p><span>As shown in Program 3.</span></p></td><td><p><span>overridden equals() and hashCode() method </span><span>are not called when put, get methods are called in </span><span>IdentityHashMap</span><span>.</span></p><p><span>Because IdentityHashMap implements </span><span>equals() and hashCode() method </span><span>by itself and checks for </span><span>reference-equality </span><span>of keys.</span></p><p><span>As shown in Program 4.</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>Application - can maintain </span><span>proxy object</span></p></td><td><p><span>HashMap cannot be used to maintain </span><span>proxy object.</span></p></td><td><p><span>IdentityHashMap can be used to maintain </span><span>proxy objects</span><span>. For example, we might need to maintain proxy object for each object debugged in the program.</span></p></td></tr></tbody></table>

Collection interview Question 20. What is WeakHashMap in java?

Answer.  Another tricky collection framework interview question for experienced developers in java.

java.util.[WeakHashMap](http://www.javamadesoeasy.com/2015/04/weakhashmap-in-java.html) is hash table based implementation of the Map interface, with weak keys.

An entry in a WeakHashMap will be automatically removed by garbage collector when its key is no longer in ordinary use. Mapping for a given key will not prevent the key from being discarded by the garbage collector, (i.e. made finalizable, finalized, and then reclaimed). When a key has been discarded its entry is removed from the map in java.

java.util.WeakHashMap is implementation of the java.util.[Map](http://www.javamadesoeasy.com/2015/04/map-hierarchy-in-java-detailed-hashmap.html) interface in java.

The behavior of the java.util.WeakHashMap class depends upon garbage collector

The behavior of the WeakHashMap class depends upon garbage collector in java. Because the garbage collector may discard keys at any time, in WeakHashMap it may look like some unknown thread is silently removing entries. Even if you synchronize WeakHashMap instance and invoke none of its methods,

-   it is possible for the size method to return smaller values over time,
    
-   for isEmpty method to return false and then true,
    
-   for containsKey method to return true and later false for a given key,
    
-   for get method to return a value for a given key but later return null,
    
-   for put method to return null, and
    
-   for remove method to return false for a key that previously existed in the WeakHashMap.
    

Each key object in a WeakHashMap is stored indirectly as the referent of a weak reference. Therefore a key will be removed automatically only after the weak references to it, both inside and outside of the map, have been cleared by the garbage collector.

Collection interview Question 21. What is EnumSet in java?

Answer. Freshers must know about EnumMap in java.

A java.util.[EnumSet](http://www.javamadesoeasy.com/2015/04/enumset-in-java-with-program.html) is specialized [Set](http://www.javamadesoeasy.com/2015/04/set-hierarchy-in-java-detailed-hashset.html) implementation for use with enum types in java.

EnumSet all elements comes from a single enum type that is specified when the set is created in java.

Order of elements in EnumSet in java

The java.util.EnumSet maintains natural order (the order in which the enum constants are declared) of elements in java.

Iterator on EnumSet in java

The iterator returned by the iterator method traverses the elements in their natural order (the order in which the enum constants are declared).

iterator never throw ConcurrentModificationException and it may or may not show the effects of any modifications to the set that occur while the iteration is in progress.

Null elements in EnumSet in java

Null elements are not allowed in EnumSet in java. Attempts to insert a null element will throw NullPointerException in java.

Collection interview Question 22. What is EnumMap in java?

Answer. Freshers must be able to answer this collection framework interview question in java. A java.util.[EnumMap](http://www.javamadesoeasy.com/2015/04/enummap-in-java-with-program.html) is specialized [Map](http://www.javamadesoeasy.com/2015/04/map-hierarchy-in-java-detailed-hashmap.html) implementation for use with enum type keys.

EnumMap all keys comes from a single enum type that is specified when the set is created in java.

Order of keys in EnumMap in java

The EnumMap maintains natural order (the order in which the enum constants are declared) of keys in java.

Iterator on EnumMap in java

The iterator returned by the iterator method in EnumMap traverses the elements in their natural order of keys(the order in which the enum constants are declared).

iterator never throw ConcurrentModificationException and it may or may not show the effects of any modifications to the map that occur while the iteration is in progress in java.

Null allowed in EnumMap in java?

Null keys are not allowed in EnumMap. Attempts to insert a null key will throw NullPointerException.

But, Null values are allowed in EnumMap in java.

Collection interview Question 23. How to implement own/custom HashMap in java? Or How HashMap works in java?

Answer.

Collection interview Question 24. How to implement own LinkedHashMap in java? Or LinkedHashMap works in java?

Answer.

Collection interview Question 25. How to implement own ArrayList in java?Or How ArrayList works in java ?

Collection interview Question 26. How to implement own HashSet in java? Or How HashSet works in java ?

Collection interview Question 27. How to implement own LinkedHashSet in java? Or How LinkedHashSet works in java ?

Collection interview Question 28. What do you mean by fail-fast and fast-safe? What is ConcurrentModificationException?

Answer.

Iterator returned by few Collection framework Classes are fail-fast, means any structural modification made to these classes during iteration will throw ConcurrentModificationException.

Some important classes whose returned iterator is fail-fast >

Iterator returned by few Collection framework Classes are fail-safe, means any structural modification made to these classes during iteration won’t throw any Exception.

Some important classes whose returned iterator is fail-safe >

-   ### [CopyOnWriteArrayList](http://www.javamadesoeasy.com/2015/04/arraylist-vs-copyonwritearraylist.html)
    
-   ### [CopyOnWriteArraySet](http://www.javamadesoeasy.com/2015/04/hashset-vs-copyonwritearrayset.html)
    
-   ### [ConcurrentSkipListSet](http://www.javamadesoeasy.com/2015/04/treeset-vs-concurrentskiplistset.html)
    

### For more detail read : [ConcurrentModificationException, Fail-fast and Fail-safe in detail in java](http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html)

Collection interview Question 29. What are different ways of iterating over elements in List?

Answer.

<table><colgroup><col width="522"></colgroup><tbody><tr><td><p><span>List&lt;String&gt; arrayList=</span><span>new</span><span> ArrayList&lt;String&gt;();</span></p><p><span>arrayList.add(</span><span>"javaMadeSoEasy"</span><span>); &nbsp;</span></p></td></tr></tbody></table>

1.  Iterate over elements in ArrayList using iterator()
    

iterator() method returns iterator to iterate over elements in ArrayList.

<table><colgroup><col width="570"></colgroup><tbody><tr><td><p><span>&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>Iterator&lt;String&gt; iterator=arrayList.iterator();</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>while</span><span>(iterator.hasNext()){</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>System.</span><span>out</span><span>.println(iterator.next());</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>}</span></p></td></tr></tbody></table>

iterator returned by ArrayList is [fail-fast](http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html).

2.  Iterate over elements in ArrayList using listIterator()
    

<table><colgroup><col width="574"></colgroup><tbody><tr><td><p><span>ListIterator&lt;String&gt; listIterator=arrayList.listIterator();</span></p></td></tr></tbody></table>

ListIterator returned by ArrayList is also fail fast.

3.  Iterate over elements in list using enumeration
    

<table><colgroup><col width="583"></colgroup><tbody><tr><td><p><span>&nbsp;&nbsp;Enumeration&lt;String&gt; listEnum=Collections.</span><span>enumeration</span><span>(arrayList);</span><span><span></span></span></p><p><span>&nbsp;&nbsp;&nbsp;</span><span>while</span><span>(listEnum.hasMoreElements()){</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.</span><span>out</span><span>.println(listEnum.nextElement());</span><span><span></span></span></p><p><span>&nbsp;&nbsp;&nbsp;}</span></p></td></tr></tbody></table>

enumeration is also fail-fast.

4.  Iterate over elements in list using enhanced for loop
    

<table><colgroup><col width="578"></colgroup><tbody><tr><td><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>for</span><span> (String string : arrayList) {</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span><span></span></span><span>System.</span><span>out</span><span>.println(string);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span><span></span></span><span>}</span></p></td></tr></tbody></table>

enhanced for loop is also fail-fast.

Collection interview Question 30. What are different ways of iterating over elements in Set?

Answer. Creating [HashSet](http://www.javamadesoeasy.com/2015/04/hashset-in-java.html) and add element.

<table><colgroup><col width="521"></colgroup><tbody><tr><td><p><span>Set&lt;String&gt; hashSet=</span><span>new</span><span> HashSet&lt;String&gt;();</span></p><p><span>hashSet.add(</span><span>"javaMadeSoEasy"</span><span>); &nbsp;</span></p></td></tr></tbody></table>

1.  Iterate over elements in HashSet using iterator()
    

iterator() method returns iterator to iterate over elements in HashSet.

<table><colgroup><col width="572"></colgroup><tbody><tr><td><p><span>&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>Iterator&lt;String&gt; iterator=hashSet.iterator();</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>while</span><span>(iterator.hasNext()){</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>System.</span><span>out</span><span>.println(iterator.next());</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>}</span></p></td></tr></tbody></table>

iterator returned by HashSet is [fail-fast](http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html).

2.  Iterate over elements in Set using enumeration
    

<table><colgroup><col width="568"></colgroup><tbody><tr><td><p><span>&nbsp;&nbsp;&nbsp;Enumeration&lt;String&gt; listEnum=Collections.</span><span>enumeration</span><span>(set); &nbsp;&nbsp;</span></p><p><span>&nbsp;&nbsp;&nbsp;</span><span>while</span><span>(listEnum.hasMoreElements()){</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.</span><span>out</span><span>.println(listEnum.nextElement());</span><span><span></span></span></p><p><span>&nbsp;&nbsp;&nbsp;}</span></p></td></tr></tbody></table>

enumeration is also fail-fast.

3.  Iterate over elements in Set using enhanced for loop
    

<table><colgroup><col width="579"></colgroup><tbody><tr><td><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>for</span><span> (String string : set) {</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span><span></span></span><span>System.</span><span>out</span><span>.println(string);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span><span></span></span><span>}</span></p></td></tr></tbody></table>

enhanced for loop is also fail-fast.

Collection interview Question 31. What are different ways of iterating over keys, values and entry in Map?

Answer. Create and put key-value pairs in [HashMap](http://www.javamadesoeasy.com/2015/04/hashmap-in-java.html) >

<table><colgroup><col width="521"></colgroup><tbody><tr><td><p><span>Map&lt;Integer,String&gt; hashMap=</span><span>new</span><span> HashMap&lt;Integer,String&gt;(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashMap.put(11, </span><span>"javaMadeSoEasy"</span><span>);</span></p><p><span>hashMap.put(21, </span><span>"bmw"</span><span>);</span></p><p><span>hashMap.put(31, </span><span>"ferrari"</span><span>);</span></p></td></tr></tbody></table>

1.  Iterate over keys -
    

hashMap.keySet().iterator() method returns iterator to iterate over keys in HashMap.

<table><colgroup><col width="531"></colgroup><tbody><tr><td><p><span>Iterator&lt;Integer&gt; keyIterator=hashMap.keySet().iterator();</span></p><p><span>while</span><span>(keyIterator.hasNext()){</span></p><p><span>&nbsp;System.</span><span>out</span><span>.println(keyIterator.next());</span></p><p><span>}</span></p><p><span>/*OUTPUT</span><span></span></p><p><span>21</span></p><p><span>11</span></p><p><span>31</span></p><p><span>*/</span><span></span></p></td></tr></tbody></table>

2.  Iterate over values -
    

hashMap.values().iterator() method returns iterator to iterate over keys in HashMap.

<table><colgroup><col width="531"></colgroup><tbody><tr><td><p><span>Iterator&lt;String&gt; valueIterator=hashMap.values().iterator();</span></p><p><span>while</span><span>(valueIterator.hasNext()){</span></p><p><span>&nbsp;System.</span><span>out</span><span>.println(valueIterator.next());</span></p><p><span>}</span></p><p><span>/*OUTPUT</span></p><p><span>javaMadeSoEasy</span></p><p><span>audi</span></p><p><span>ferrari</span></p><p><span>*/</span></p></td></tr></tbody></table>

3.  Iterate over Entry-
    

hashMap.entrySet().iterator() method returns iterator to iterate over keys in HashMap.

<table><colgroup><col width="531"></colgroup><tbody><tr><td><p><span>Iterator&lt;Entry&lt;Integer, String&gt;&gt; entryIterator=hashMap.entrySet().iterator();</span><span><span></span></span></p><p><span>while</span><span>(entryIterator.hasNext()){</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>System.</span><span>out</span><span>.println(entryIterator.next());</span></p><p><span>}</span></p><p><span>/*OUTPUT</span></p><p><span>21=javaMadeSoEasy</span></p><p><span>11=audi</span></p><p><span>31=ferrari</span></p><p><span>*/</span></p></td></tr></tbody></table>

Collection interview Question 32. What is difference between [Comparable and Comparator](http://www.javamadesoeasy.com/2015/04/comparable-vs-comparator-differences.html)? How can you sort List?

Answer.

<table><colgroup><col width="27"><col width="72"><col width="286"><col width="293"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>Comparable</span></p></td><td><p><span>Comparator</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>Comparing instances of class</span></p></td><td><p><span>Comparable is used to compare instances of same class</span></p></td><td><p><span>Comparator can be used to compare instances of same or different classes.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>sorting order</span><span></span></p></td><td><p><span>Comparable can be implemented by class which need to define a </span><span>natural ordering for its objects.</span><span></span></p><p><span>Example </span><span>- String, Integer, Long , </span><a href="http://www.javamadesoeasy.com/2015/07/creating-date-in-java-using-calendar.html"><span>Date</span></a><span> and all other wrapper classes implements Comparable.</span></p></td><td><p><span>Comparator is implemented when one wants a </span><span>different sorting order</span><span> and define custom way of comparing two instances.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Changes to class</span></p></td><td><p><span>For using Comparable, original Class must implement it.</span></p><p><span>Example-</span></p><p><span>class</span><span> Employee </span><span>implements</span><span> Comparable&lt;Employee&gt;</span></p><p><span>For using Comparable, Employee Class must implement it, no other class can implement it.</span></p><p><span>As used in </span><span>Program 1</span></p></td><td><p><span>Class itself can implement Comparator</span></p><p><span>or</span></p><p><span>any other class can implement Comparator. Hence avoiding modification to original class.</span></p><p><span>Example-</span></p><p><span>class</span><span> ComparatorName </span><span>implements</span><span> Comparator&lt;Employee&gt;</span></p><p><span>class</span><span> ComparatorId </span><span>implements</span><span> Comparator&lt;Employee&gt;</span></p><p><span>In above example modifications were made to </span><span>ComparatorName </span><span>and </span><span>ComparatorId. </span><span>Hence avoiding modification to Employee class.</span></p><p><span>As used in </span><span>Program 4</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Sorting on basis on one or many criteria</span></p></td><td><p><span>Provides sorting only on </span><span>one </span><span>criteria, </span><span>because </span><span>Comparable can be implemented by original class only.</span></p><br></td><td><p><span>We can use Comparator to sort class on </span><span>many </span><span>criterias </span><span>because </span><span>class itself or any other class can implement Comparator.</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Method</span></p></td><td><p><span>compareTo method</span></p><p><span>@Override</span></p><p><span>public</span><span> </span><span>int</span><span> compareTo(Employee obj) {</span></p><p><span></span><span>//sort Employee on basis of name(ascending order)</span></p><p><span>&nbsp;</span><span>return</span><span> </span><span>this</span><span>.</span><span>name</span><span>.compareTo(obj.</span><span>name</span><span>);</span></p><p><span>}</span></p><p><span>Method compares </span><span>this </span><span>with </span><span>obj </span><span>object and returns a integer.</span></p><br><ul><li dir="ltr"><p><span>positive – </span><span>this </span><span>is </span><span>greater </span><span>than </span><span>obj</span></p></li><li dir="ltr"><p><span>zero – </span><span>this </span><span>is </span><span>equal </span><span>to </span><span>obj</span></p></li><li dir="ltr"><p><span>negative – </span><span>this </span><span>is </span><span>less </span><span>than </span><span>obj</span></p></li></ul><p><span>As used in </span><span>Program 1</span></p></td><td><p><span>compare method</span></p><p><span>@Override</span></p><p><span>public</span><span> </span><span>int</span><span> compare(Employee obj1, Employee obj2) {</span></p><p><span></span><span>//sort Employee on basis of name(ascending order)</span></p><p><span>&nbsp;&nbsp;&nbsp;</span><span>return</span><span> obj1.</span><span>name</span><span>.compareTo(obj2.</span><span>name</span><span>);</span></p><p><span>}</span></p><p><span>Method compares </span><span>obj1 </span><span>with </span><span>obj2 </span><span>object and returns a integer.</span></p><br><ul><li dir="ltr"><p><span>positive – </span><span>obj1 </span><span>is </span><span>greater </span><span>than </span><span>obj2</span></p></li><li dir="ltr"><p><span>zero – </span><span>obj1 </span><span>is </span><span>equal </span><span>to </span><span>obj2</span></p></li><li dir="ltr"><p><span>negative – </span><span>obj1 </span><span>is </span><span>less </span><span>than </span><span>obj2</span></p></li></ul><p><span>As used in </span><span>Program 3</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>Package</span></p></td><td><p><span>java.lang</span><span></span></p><p><span>java.lang</span><span> package is automatically imported by every program in java.</span></p><p><span>Hence, </span><span>we need to write explicit statement for importing java.lang.Comparable.</span></p></td><td><p><span>java.util</span></p><p><span>We need to write explicit import statement -</span></p><p><span>import</span><span> java.util.Comparator</span></p></td></tr><tr><td><p><span>7</span></p></td><td><p><span>Using </span><span>Collections.sort</span></p></td><td><p><span>Let's say we wanna sort list of Employee,</span></p><p><span>Collections.sort(</span><span>list</span><span>) </span><span>uses Comparable interface for sorting class.</span></p><p><span>As used in Program 1</span></p></td><td><p><span>Let's say we wanna sort list of Employee,</span></p><p><span>Collections.</span><span>sort</span><span>(list,</span><span>new</span><span> ComparatorName());</span></p><p><span>uses Comparator interface for sorting class.</span></p><p><span>As used in Program 5</span></p></td></tr></tbody></table>

Collection interview Question 33. How sort method of Collections class works internally?

Answer. Collections.sort internally calls Arrays.sort,

Arrays.Sort() internally uses [Merge Sort](http://javamadesoeasy.blogspot.in/2015/01/merge-sort.html).

If number of elements is less than 7 then [Insertion Sort](http://www.javamadesoeasy.com/2015/01/insertion-sort.html) is used rather than [Merge Sort](http://javamadesoeasy.blogspot.in/2015/01/merge-sort.html). (because in case elements are less than 7 it offers better time complexity)

Collection interview Question 34. How can you sort given HashMap on basis of keys?

Answer.

### Please Read : [Sort Map by key in Ascending and descending order by implementing Comparator interface and overriding its compare method and using TreeMap](http://www.javamadesoeasy.com/2015/04/sort-map-by-key-in-ascending-and.html)

Collection interview Question 35. How can you sort given HashMap on basis of values?

Answer.

### Please Read : [Sort Map by value in Ascending and descending order by implementing Comparator interface and overriding its compare method](http://www.javamadesoeasy.com/2015/04/sort-map-by-value-in-ascending-and.html)

Collection interview Question 36. In what all possible ways you can sort a given Set?

Answer.

Collection interview Question 37. How you can sort arrays? And how Comparator of superclass can be used by subclasses?

Answer.

Answer.

Differences between java.util.[ArrayList](http://www.javamadesoeasy.com/2015/04/arraylist-in-java.html) and java.util.concurrent.CopyOnWriteArrayList  in java >

<table><colgroup><col width="21"><col width="111"><col width="224"><col width="268"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.ArrayList</span></p></td><td><p><span>java.util.concurrent. CopyOnWriteArrayList</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>synchronization</span></p></td><td><p><span>ArrayList is not </span><span>synchronized </span><span>&nbsp;(because 2 threads on same ArrayList object can access it at same time).</span></p><p><span>I have created </span><span>program </span><span>to show see consequence of using ArrayList in multithreading environment.</span></p><p><span>In the program i will implement our own arrayList.</span></p></td><td><p><span>CopyOnWriteArrayList &nbsp;</span><span>is </span><span>synchronized </span><span>&nbsp;(because 2 threads on same CopyOnWriteArrayList object cannot access it at same time).</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Iterator and listIterator</span></p></td><td><p><span>Iterator and listIterator returned by ArrayList are </span><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>Fail-fast</span></a><span>,</span><span> means any structural modification made to ArrayList during iteration using Iterator or listIterator will throw </span><span>ConcurrentModificationException</span><span> in java.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>Iterator and listIterator returned by CopyOnWriteArrayList are </span><span>Fail-safe</span><span> in java.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Enumeration is fail-fast</span></p></td><td><p><span>Enumeration </span><span>returned by ArrayList is </span><span>fail-fast</span><span>, means any structural modification made to ArrayList during iteration using Enumeration will throw </span><span>ConcurrentModificationException</span><span>.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>Enumeration </span><span>returned by CopyOnWriteArrayList is </span><span>fail-safe.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Iterate using </span><span>enhanced for loop</span></p></td><td><p><span>Iteration done on ArrayList using </span><span>enhanced for loop </span><span>is </span><span>Fail-fast,</span><span> means any structural modification made to ArrayList during iteration using </span><span>enhanced for loop</span><span> will throw </span><span>ConcurrentModificationException</span><span>.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>Iteration done on CopyOnWriteArrayList using </span><span>enhanced for loop </span><span>is </span><span>Fail-safe.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Performance</span></p></td><td><p><span>ArrayList is not synchronized, hence its operations are </span><span>faster </span><span>as compared to CopyOnWriteArrayList.</span></p></td><td><p><span>CopyOnWriteArrayList is synchronized, hence its operations are </span><span>slower </span><span>as compared to ArrayList.</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>AbstractList</span></p></td><td><p><span>ArrayList extends AbstractList (</span><span>abstract class</span><span>) which provides implementation to &nbsp;List interface </span><span>to minimize the effort required to implement this interface backed by RandomAccess interface</span><span>.</span></p></td><td><p><span>CopyOnWriteArrayList does not extends AbstractList,</span><span> though CopyOnWriteArrayList also implements RandomAccess interface.</span></p></td></tr><tr><td><p><span>7</span></p></td><td><p><span>Introduced in which java version</span></p></td><td><p><span>ArrayList was introduced in second version of java (1.2) i.e. </span><span>JDK 2.0</span></p></td><td><p><span>CopyOnWriteArrayList was introduced in fifth version of java (1.5) i.e. </span><span>JDK 5.0</span></p></td></tr><tr><td><p><span>8</span></p></td><td><p><span>Package</span></p></td><td><p><span>java.util</span></p></td><td><p><span>java.util.</span><span>concurrent</span></p></td></tr></tbody></table>

Answer.

Differences between java.util.[HashSet](http://www.javamadesoeasy.com/2015/04/hashset-in-java.html)  and java.util.concurrent.CopyOnWriteArraySet in java >

<table><colgroup><col width="21"><col width="107"><col width="227"><col width="271"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.HashSet</span></p></td><td><p><span>java.util.concurrent. CopyOnWriteArraySet</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>synchronization</span></p></td><td><p><span>HashSet is not </span><span>synchronized </span><span>&nbsp;(because 2 threads on same HashSet object can access it at same time) in java.</span></p></td><td><p><span>CopyOnWriteArraySet &nbsp;</span><span>is </span><span>synchronized </span><span>&nbsp;(because 2 threads on same CopyOnWriteArraySet object cannot access it at same time) in java.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Iterator</span></p></td><td><p><span>Iterator returned by HashSet is </span><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>Fail-fast</span></a><span>,</span><span> means any structural modification made to HashSet during iteration using Iterator will throw </span><span>ConcurrentModificationException</span><span> in java.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>Iterator returned by </span><span>CopyOnWriteArraySet </span><span>is </span><span>Fail-safe</span><span> in java.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Enumeration is fail-fast</span></p></td><td><p><span>Enumeration </span><span>returned by HashSet is </span><span>fail-fast</span><span>, means any structural modification made to HashSet during iteration using Enumeration will throw </span><span>ConcurrentModificationException</span><span>.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>Enumeration </span><span>returned by CopyOnWriteArraySet is </span><span>fail-safe.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Iterate using </span><span>enhanced for loop</span></p></td><td><p><span>Iteration done on HashSet using </span><span>enhanced for loop </span><span>is </span><span>Fail-fast,</span><span> means any structural modification made to HashSet during iteration using </span><span>enhanced for loop</span><span> will throw </span><span>ConcurrentModificationException</span><span>.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>Iteration done on CopyOnWriteArraySet using </span><span>enhanced for loop </span><span>is </span><span>Fail-safe.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Performance</span></p></td><td><p><span>HashSet is not synchronized, hence its operations are </span><span>faster </span><span>as compared to CopyOnWriteArraySet.</span></p></td><td><p><span>CopyOnWriteArraySet is synchronized, hence its operations are </span><span>slower </span><span>as compared to HashSet.</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>Introduced in which java version</span></p></td><td><p><span>HashSet was introduced in second version of java (1.2) i.e. </span><span>JDK 2.0</span></p></td><td><p><span>CopyOnWriteArraySet &nbsp;was introduced in fifth version of java (1.5) i.e. </span><span>JDK 5.0</span></p></td></tr><tr><td><p><span>7</span></p></td><td><p><span>Package</span></p></td><td><p><span>java.util</span></p></td><td><p><span>java.util.</span><span>concurrent</span></p></td></tr></tbody></table>

### For more detail read : [HashSet vs CopyOnWriteArraySet - Similarity and Differences with program](http://www.javamadesoeasy.com/2015/04/hashset-vs-copyonwritearrayset.html)

Answer.

Differences between java.util.[TreeSet](http://www.javamadesoeasy.com/2015/04/hashset-vs-linkedhashset-vs-treeset.html)  and java.util.concurrent.ConcurrentSkipListSet in java \>

<table><colgroup><col width="21"><col width="111"><col width="220"><col width="272"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.TreeSet</span></p></td><td><p><span>java.util.concurrent. ConcurrentSkipListSet</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>synchronization</span></p></td><td><p><span>TreeSet is not </span><span>synchronized </span><span>&nbsp;(because 2 threads on same TreeSet object can access it at same time) in java.</span></p></td><td><p><span>ConcurrentSkipListSet &nbsp;</span><span>is </span><span>synchronized </span><span>&nbsp;(because 2 threads on same ConcurrentSkipListSet object cannot access it at same time) in java.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Iterator</span></p></td><td><p><span>Iterator returned by TreeSet is </span><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>Fail-fast</span></a><span>,</span><span> means any structural modification made to TreeSet during iteration using Iterator will throw </span><span>ConcurrentModificationException</span><span> in java.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>Iterator returned by </span><span>ConcurrentSkipListSet </span><span>is </span><span>Fail-safe</span><span> in java.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Enumeration is fail-fast</span></p></td><td><p><span>Enumeration </span><span>returned by TreeSet is </span><span>fail-fast</span><span>, means any structural modification made to TreeSet during iteration using Enumeration will throw </span><span>ConcurrentModificationException</span><span>.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>Enumeration </span><span>returned by ConcurrentSkipListSet is </span><span>fail-safe.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Iterate using </span><span>enhanced for loop</span></p></td><td><p><span>Iteration done on TreeSet using </span><span>enhanced for loop </span><span>is </span><span>Fail-fast,</span><span> means any structural modification made to TreeSet during iteration using </span><span>enhanced for loop</span><span> will throw </span><span>ConcurrentModificationException</span><span>.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>Iteration done on ConcurrentSkipListSet using </span><span>enhanced for loop </span><span>is </span><span>Fail-safe.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Performance</span></p></td><td><p><span>TreeSet is not synchronized, hence its operations are </span><span>faster </span><span>as compared to ConcurrentSkipListSet.</span></p></td><td><p><span>ConcurrentSkipListSet is synchronized, hence its operations are </span><span>slower </span><span>as compared to TreeSet.</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>Introduced in which java version</span></p></td><td><p><span>TreeSet was introduced in second version of java (1.2) i.e. </span><span>JDK 2.0</span></p></td><td><p><span>ConcurrentSkipListSet was introduced in sixth version of java (1.6) i.e. </span><span>JDK 6.0</span></p></td></tr><tr><td><p><span>7</span></p></td><td><p><span>Package</span></p></td><td><p><span>java.util</span></p></td><td><p><span>java.util.</span><span>concurrent</span></p></td></tr></tbody></table>

### For more detail read : [TreeSet vs ConcurrentSkipListSet - Similarity and Differences with program](http://www.javamadesoeasy.com/2015/04/treeset-vs-concurrentskiplistset.html)

Answer.

Differences between java.util.[TreeMap](http://www.javamadesoeasy.com/2015/04/hashmap-vs-hashtable-vs-linkedhashmap.html) and java.util.concurrent.ConcurrentSkipListMap in java >

<table><colgroup><col width="21"><col width="120"><col width="233"><col width="251"></colgroup><tbody><tr><td><br></td><td><p><span>Property</span></p></td><td><p><span>java.util.TreeMap</span></p></td><td><p><span>java.util.concurrent. ConcurrentSkipListMap</span></p></td></tr><tr><td><p><span>1</span></p></td><td><p><span>synchronization</span></p></td><td><p><span>TreeMap is </span><span>not synchronized </span><span>&nbsp;(because 2 threads on same TreeMap object can access it at same time) in java.</span></p><br></td><td><p><span>ConcurrentSkipListMap is </span><span>synchronized</span><span> (because 2 threads on same ConcurrentSkipListMap object cannot access it at same time) in java.</span></p></td></tr><tr><td><p><span>2</span></p></td><td><p><span>Iterator</span></p></td><td><p><span>The iterators returned by the iterator() method of Map's “collection view methods" are </span><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>fail-fast</span></a><span>&gt;</span></p><ul><li dir="ltr"><p><span>map.keySet().iterator()</span></p></li><li dir="ltr"><p><span>map.values().iterator()</span></p></li><li dir="ltr"><p><span>map.entrySet().iterator()</span></p></li></ul><p><span>all three iterators are </span><span>fail-fast</span><span>,</span><span> means any structural modification made to TreeMap during iteration using any of 3 Iterator will throw </span><span>ConcurrentModificationException</span><span>.</span></p><p><span>As shown in Program 1 below.</span></p></td><td><p><span>The iterators returned by the iterator() method of Map's “collection view methods" are </span><span>fail-safe &gt;</span></p><ul><li dir="ltr"><p><span>map.keySet().iterator()</span></p></li><li dir="ltr"><p><span>map.values().iterator()</span></p></li><li dir="ltr"><p><span>map.entrySet().iterator()</span></p></li></ul><p><span>all three iterators are </span><span>fail-safe.</span></p><p><span>As shown in Program 2 below.</span></p></td></tr><tr><td><p><span>3</span></p></td><td><p><span>Performance</span></p></td><td><p><span>TreeMap is not synchronized, hence its operations are </span><span>faster </span><span>as compared to ConcurrentSkipListMap.</span></p></td><td><p><span>ConcurrentSkipListMap is synchronized, hence its operations are </span><span>slower </span><span>as compared to TreeMap.</span></p></td></tr><tr><td><p><span>4</span></p></td><td><p><span>Introduced inin which java version</span></p></td><td><p><span>TreeMap was introduced in second version of java i.e. </span><span>JDK 2.0</span></p></td><td><p><span>ConcurrentSkipListMap was introduced in sixth version of java i.e. </span><span>JDK 6.0</span></p></td></tr><tr><td><p><span>5</span></p></td><td><p><span>Package</span></p></td><td><p><span>java.util</span></p></td><td><p><span>java.util.</span><span>concurrent</span></p></td></tr><tr><td><p><span>6</span></p></td><td><p><span>Implements which interface</span></p></td><td><p><span>Map</span></p><p><span>SortedMap</span></p><p><span>NavigableMap</span></p></td><td><p><span>Map</span></p><p><span>SortedMap</span></p><p><span>NavigableMap</span></p><p><span>ConcurrentNavigableMap</span></p></td></tr></tbody></table>

### For more detail read : [TreeMap vs ConcurrentSkipListMap - Similarity and Differences with program](http://www.javamadesoeasy.com/2015/04/treemap-vs-concurrentskiplistmap.html)

Collection interview Question 43. Can we use null element in TreeSet? Give reason?

Answer. No, [TreeSet](http://www.javamadesoeasy.com/2015/04/hashset-vs-linkedhashset-vs-treeset.html) does not allows to store any null keys.

Any attempt to add null throws runtimeException (NullPointerException).

TreeSet internally compares elements for sorting elements by natural order ([comparator may be used for sorting](http://www.javamadesoeasy.com/2015/04/program-to-sort-set-in-ascending-order_24.html), if defined at creation time) and null is not comparable, Any attempt to compare null with other object will throw NullPointerException.

Collection interview Question 44. Can we use null key in TreeMap? Give reason?

Answer. No, [TreeMap](http://www.javamadesoeasy.com/2015/04/treemap-vs-concurrentskiplistmap.html) not allow to store null key.

Any attempt to store null key throws runtimeException (NullPointerException).

TreeMap internally compares keys for sorting keys by natural order ([comparator may be used for sorting](http://www.javamadesoeasy.com/2015/04/program-to-sort-set-in-ascending-order_24.html), if defined at creation time)  and null is not comparable, Any attempt to compare null with other object will throw NullPointerException.

Collection interview Question 45.  How ConcurrentHashMap works? Can 2 threads on same ConcurrentHashMap object access it concurrently?

Answer. [ConcurrentHashMap](http://www.javamadesoeasy.com/2015/04/hashmap-and-concurrenthashmap.html) is divided into different segments based on concurrency level. So different threads can access different segments concurrently.

Can threads read the segment locked by some other thread?

Yes. When thread locks one segment for updation it does not block it for retrieval (done by get method) hence some other thread can read the segment (by get method), but it will be able to read the data before locking.

For operations such as putAll concurrent retrievals may reflect removal of only some entries.

For operations such as clear concurrent retrievals may reflect removal of only some entries.

Segments in ConcurrentHashMap with diagram \>

we have ConcurrentHashMap with 4 segments -

(Diagram shows how segments are formed in ConcurrentHashMap)

[![](https://lh5.googleusercontent.com/Gzas9ylGZqwrU9aSMHfH7DJUTsDNYm18NCNMiVbxagCeCPlenPN9rI7MoXjGki2r-b7EdoO_IhfH-7sn2F94mmHtj80ooZXuFeZjaR1-g4qytbHXGkmj53pUTiBrHYXVJPmrTTQ)](http://www.javamadesoeasy.com/2015/04/hashmap-and-concurrenthashmap.html)

Collection interview Question 46. Write a program to show consequence of using ArrayList in multithreading environment?

Collection interview Question 47. Write a program to show advantage of using Vector in multithreading environment?

Collection interview Question 48. Mention properties of most frequently used Collection classes and Interfaces? Mention as many properties as much you can.

Answer. This question is real test for experienced developers, this will test your in depth awareness of Collection classes and Interfaces. Answering this question in detail will really ensure your selection.

<table><colgroup><col width="196"><col width="47"><col width="61"><col width="62"><col width="105"><col width="76"><col width="153"></colgroup><tbody><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/list-hierarchy-in-java-detailed.html"><span>List</span></a></p></div></td><td><p><span>Duplicate elements</span></p></td><td><p><span>insertion order</span></p></td><td><p><span>Sorted by natural order</span></p></td><td><p><span>synchronized</span></p></td><td><p><span>null elements</span></p></td><td><p><span>Iterator</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/arraylist-in-java.html"><span>ArrayList</span></a></p></div></td><td><p><span>Yes</span></p></td><td><p><span>Yes</span></p></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><p><span>Iterator &amp; listIterator</span></p><p><span>are</span></p><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>Fail-fast</span></a></p></div></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/linkedlist-in-java.html"><span>LinkedList</span></a></p></div></td><td><p><span>Yes</span></p></td><td><p><span>Yes</span></p></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><p><span>Iterator &amp; listIterator</span></p><p><span>are</span></p><p><span>Fail-fast</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/arraylist-vs-copyonwritearraylist.html"><span>CopyOnWriteArrayList</span></a></p></div></td><td><p><span>Yes</span></p></td><td><p><span>Yes</span></p></td><td><br></td><td><p><span>Yes</span></p></td><td><p><span>Yes</span></p></td><td><p><span>Iterator &amp; listIterator</span></p><p><span>are</span></p><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/concurrentmodificationexception-fail.html"><span>Fail-safe</span></a></p></div></td></tr><tr><td><br></td><td><br></td><td><br></td><td><br></td><td><br></td><td><br></td><td><br></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/set-hierarchy-in-java-detailed-hashset.html"><span>Set</span></a></p></div></td><td><p><span>Duplicate elements</span></p></td><td><p><span>insertion order</span></p></td><td><p><span>Sorted by natural order</span></p></td><td><p><span>synchronized</span></p></td><td><p><span>null elements</span></p></td><td><p><span>Iterator</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/hashset-in-java.html"><span>HashSet</span></a></p></div></td><td><br></td><td><br></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><p><span>Fail-fast</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/hashset-vs-linkedhashset-vs-treeset.html"><span>LinkedHashSet</span></a></p></div></td><td><br></td><td><p><span>Yes</span></p></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><p><span>Fail-fast</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/hashset-vs-linkedhashset-vs-treeset.html"><span>TreeSet</span></a></p></div></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><br></td><td><p><span>No</span></p></td><td><p><span>Fail-fast</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/treeset-vs-concurrentskiplistset.html"><span>ConcurrentSkipListSet</span></a></p></div></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><p><span>Yes</span></p></td><td><p><span>No</span></p></td><td><p><span>Fail-safe</span></p></td></tr><tr><td><br></td><td><br></td><td><br></td><td><br></td><td><br></td><td><br></td><td><br></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/map-hierarchy-in-java-detailed-hashmap.html"><span>Map</span></a></p></div></td><td><p><span>Duplicate Keys</span></p></td><td><p><span>insertion order of keys</span></p></td><td><p><span>Sorted by natural order of keys</span></p></td><td><p><span>synchronized</span></p></td><td><p><span>null keys or null values</span></p></td><td><p><span>Iterator</span></p><p><span>Map implementations returns 3 iterators &gt;</span></p><p><span>map.keySet().iterator()</span></p><p><span>map.values().iterator()</span></p><p><span>map.entrySet().iterator()</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/hashmap-in-java.html"><span>HashMap</span></a></p></div></td><td><br></td><td><br></td><td><br></td><td><br></td><td><p><span>one null key and many null values</span></p></td><td><p><span>All are Fail-fast</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/hashmap-and-hashtable-similarity-and.html"><span>Hashtable</span></a></p></div></td><td><br></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><p><span>No</span></p></td><td><p><span>All are Fail-fast</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/hashmap-and-concurrenthashmap.html"><span>ConcurrentHashMap</span></a></p></div></td><td><br></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><p><span>No</span></p></td><td><p><span>All are </span><span>Fail-safe</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/hashmap-vs-hashtable-vs-linkedhashmap.html"><span>TreeMap</span></a></p></div></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><br></td><td><p><span>Null key not allowed,</span></p><p><span>Allow many null values</span></p></td><td><p><span>All are Fail-fast</span></p></td></tr><tr><td><div dir="ltr"><p><a href="http://www.javamadesoeasy.com/2015/04/treemap-vs-concurrentskiplistmap.html"><span>ConcurrentSkipListMap</span></a></p></div></td><td><br></td><td><br></td><td><p><span>Yes</span></p></td><td><p><span>Yes</span></p></td><td><p><span>No</span></p></td><td><p><span>All are </span><span>Fail-safe</span></p></td></tr></tbody></table>

Collection interview Question. 49 Which list class must be preferred in multithreading environment, considering performance constraint?

Collection interview Question 50. Which Set class must be preferred in multithreading environment, considering performance constraint?

Answer. [CopyOnWriteArraySet](http://www.javamadesoeasy.com/2015/04/hashset-vs-copyonwritearrayset.html) (allows null and elements aren't sorted in natural order) or [ConcurrentSkipListSet](http://www.javamadesoeasy.com/2015/04/treeset-vs-concurrentskiplistset.html) (doesn’t allows null and elements are sorted in natural order)

Select one depending on your requirement.

Collection interview Question 51. Which Map class must be preferred in multithreading environment, considering performance constraint?

Select one depending on your requirement.

Collection interview Question 52. Let’s say you have to build dictionary and multiple users can add data in that dictionary? And you can use 2 Collection classes? Which Collection classes you will prefer and WHY?

Answer. It’s very important question which test your logical reasoning and your ability to create robust applications in [multithreading](http://www.javamadesoeasy.com/2015/03/what-is-thread-in-java.html) environment.

<table><colgroup><col width="719"></colgroup><tbody><tr><td><p><span>ConcurrentSkipListMap&lt;String, TreeSet&lt;String&gt;&gt; myDictionary =</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>new</span><span> ConcurrentSkipListMap&lt;String, TreeSet&lt;String&gt;&gt;();</span></p></td></tr></tbody></table>

-   keys are sorted in natural order (words will be sorted in natural order),
    
-   doesn’t allow null keys (words can’t be null)
    
-   doesn’t allow duplicate keys (words can’t be duplicate) and
    
-   [synchronized](http://www.javamadesoeasy.com/2015/03/synchronization-blocks-and-methods.html), so 2 threads won’t create synchronization problems (will take care of different uses adding words concurrently)
    

for storing meaning of word in dictionary we must use [TreeSet](http://www.javamadesoeasy.com/2015/04/hashset-vs-linkedhashset-vs-treeset.html) as value in ConcurrentSkipListMap because one word can have many meanings >

-   elements are sorted in natural order (meaning of word are sorted in natural order),
    
-   doesn’t allow null elements (meaning of word can’t be null),
    
-   doesn’t allow duplicate elements (meaning of word can’t be duplicate)
    

Program for creating and using Java dictionary using Collection classes>

<table><colgroup><col width="719"></colgroup><tbody><tr><td><p><span>package</span><span> com.ankit.dictionary;</span></p><p><span>import</span><span> java.util.TreeSet;</span></p><p><span>import</span><span> java.util.concurrent.ConcurrentSkipListMap;</span></p><div dir="ltr"><p><span>/** Copyright (c), AnkitMittal <a href="http://javamadesoeasy.com/" rel="nofollow"><span>JavaMadeSoEasy</span><span>.</span><span>com</span></a> */</span></p></div><p><span>public</span><span> </span><span>class</span><span> MyDictionary {</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>public</span><span> </span><span>static</span><span> </span><span>void</span><span> main(String[] args) {</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>ConcurrentSkipListMap&lt;String, TreeSet&lt;String&gt;&gt; myDictionary =</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>new</span><span> ConcurrentSkipListMap&lt;String, TreeSet&lt;String&gt;&gt;();</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>TreeSet&lt;String&gt; innocentMeaning = </span><span>new</span><span> TreeSet&lt;String&gt;();</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>innocentMeaning.add(</span><span>"not responsible for an event yet suffering its consequences"</span><span>);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>innocentMeaning.add(</span><span>"not guilty of a crime"</span><span>);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>myDictionary.put(</span><span>"innocent"</span><span>, innocentMeaning);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>TreeSet&lt;String&gt; appealingMeaning = </span><span>new</span><span> TreeSet&lt;String&gt;();</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>appealingMeaning.add(</span><span>"attractive"</span><span>);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>appealingMeaning.add(</span><span>"expressing a desire for help"</span><span>);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>myDictionary.put(</span><span>"appealing"</span><span>, appealingMeaning);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><span> </span></span><span>System.</span><span>out</span><span>.println(myDictionary);</span></p><p><span>&nbsp;&nbsp;</span><span><span> </span></span><span>}</span></p><p><span>}</span></p><p><span>/* OUTPUT</span></p><p><span>{</span><span>appealing</span><span>=[attractive, expressing a desire for help], </span><span>innocent</span><span>=[not guilty of a crime, not responsible for an event yet suffering its consequences]}</span></p><p><span>*/</span></p></td></tr></tbody></table>

Collection interview Question 53. Why to use java.util.WeakHashMap map which is so inconsistent and unpredictable in behaviour?

Answer. Let's say we have huge application which consists of lots n lots of object and may run short of memory at any time, we will like [garbage collector](http://www.javamadesoeasy.com/2015/09/how-garbage-collection-works-internally.html) to quickly discard less used key value pair to free up some memory. As, behavior of the WeakHashMap class depends upon garbage collector.

I believe discarding less used key-value is always going to a better option than running out of memory.

### [COLLECTION - Top 100 important interview OUTPUT questions and answers in java, Set-3 > Q75- Q100](http://www.javamadesoeasy.com/2015/07/collection-top-100-important-interview45.html)